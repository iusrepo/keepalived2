From dcdc2aeafb04d09b9d7ba412d8b417c9fd072c2a Mon Sep 17 00:00:00 2001
From: Alexandre Cassen <acassen@gmail.com>
Date: Tue, 7 Jan 2014 15:38:57 +0100
Subject: [PATCH 4/7] lib: extend command lib string parser

Extend cmd_make_strvec to support quoted string as a single slot and
commented string at the end of parsed string.
---
 lib/Makefile.in |  2 +-
 lib/command.c   | 34 +++++++++++++++++++++++-----------
 2 files changed, 24 insertions(+), 12 deletions(-)

diff --git a/lib/Makefile.in b/lib/Makefile.in
index 9eb929e..ee4691f 100644
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -42,6 +42,6 @@ logger.o: logger.c logger.h
 list_head.o: list_head.c list_head.h
 buffer.o: buffer.c buffer.h memory.h
 command.o: command.c command.h vector.h memory.h vty.h timer.h \
-	config.h
+	config.h logger.h
 vty.o: vty.c vty.h scheduler.h timer.h utils.h command.h logger.h \
 	memory.h
diff --git a/lib/command.c b/lib/command.c
index eff59de..4814594 100644
--- a/lib/command.c
+++ b/lib/command.c
@@ -35,7 +35,7 @@
 #include "timer.h"
 
 /* Command vector which includes some level of command lists. Normally
- * each daemon maintains each own cmdvec. */
+ * each daemon maintains its own cmdvec. */
 vector_t *cmdvec = NULL;
 
 desc_t desc_cr;
@@ -156,7 +156,9 @@ sort_node(void)
 
 /* Breaking up string into each command piece. I assume given
  * character is separated by a space character. Return value is a
- * vector which includes char ** data element. */
+ * vector which includes char ** data element. It supports
+ * quoted string as a single slot and commented string at
+ * the end of parsed string */
 vector_t *
 cmd_make_strvec(const char *string)
 {
@@ -187,20 +189,30 @@ cmd_make_strvec(const char *string)
 	/* Copy each command piece and set into vector. */
 	while (1) {
 		start = cp;
-		while (!(isspace((int) *cp) || *cp == '\r' || *cp == '\n') &&
-		       *cp != '\0')
+		if (*cp == '"') {
 			cp++;
-		strlen = cp - start;
-		token = (char *) MALLOC(strlen + 1);
-		memcpy(token, start, strlen);
-		*(token + strlen) = '\0';
-		vector_set(strvec, token);
+			token = MALLOC(2);
+			*(token) = '"';
+			*(token + 1) = '\0';
+		} else {
+			while (!(isspace((int) *cp) || *cp == '\r' || *cp == '\n') &&
+			       *cp != '\0' && *cp != '"')
+				cp++;
+			strlen = cp - start;
+			token = (char *) MALLOC(strlen + 1);
+			memcpy(token, start, strlen);
+			*(token + strlen) = '\0';
+		}
+
+		/* Alloc & set the slot */
+		vector_alloc_slot(strvec);
+		vector_set_slot(strvec, token);
 
-		while ((isspace ((int) *cp) || *cp == '\n' || *cp == '\r') &&
+		while ((isspace((int) *cp) || *cp == '\n' || *cp == '\r') &&
 		       *cp != '\0')
 			cp++;
 
-		if (*cp == '\0')
+		if (*cp == '\0' || *cp == '!' || *cp == '#')
 			return strvec;
 	}
 }
-- 
1.8.1.4

